在上一篇中 ， 我们分析了指针在内存中是怎样存储的 ， 以及它是怎样操作变量的 ， 接下来 ， 我们谈谈 ， 函数 ， 二级指针 。

### 函数
C语言中函数的定义和java中方法的定义类似 ， 只是没有public , private等这样的权限控制 ， 定义如下：

```c
  
返回值类型 functionName(参数类型 参数名称  , 参数类型 参数名称) {
      // 函数体
  }


int add(int num1 , int num2) {
      return num1 + num2 ;
}
```

如果我们想在函数里面 ，修改传入的参数的值 ， 就如同java里面将对象传入方法中修改对象的属性 ， 在C语言通过指针也可以达到同样的效果 。

```c

 /* 想要修改传入变量的值 ， 则需要使用指针通过变量的地址 ， 来修改变量的值 */
void changeNum(int* i) {
	*i = 300;
}

```
如果不采用指针`changeNum(int i)` ， 函数参数里面的`int i` 则会为`i`变量开辟一个新的内存空间  ， 而不是我们传入的变量 。下面我们就来看看 ， 他们在内存中是怎样表现的 。
``` c
  
    /*没有使用指针的函数*/
void changeNum(int i) {

	printf("函数中i的地址：%#x\n", &i);
	i = 300;
}

void main() {

	int i = 100;

	printf("传入函数的 i 的地址：%#x\n",&i);

	// 将变量i传入到函数中 , 不对变量去区地址
	changeNum(i);

	printf("修改后的值：%d\n", i);

	system("pause");

}

```
输出：
```c

传入函数的 i 的地址：0x9a2ffcd4
函数中i的地址：0x9a2ffcb0
修改后的值：100

```
我们看到传入的`i`变量的内存地址和函数中的`i`变量内存地址不一样 ， 并且函数也没有修改我们的`i`变量 ， 我们将上述代码 ， 做一下简单的修改 ， 只要将函数的形参改变为指针变量， 将修改的变量的变量内存地址传入到函数中 ， 如此在函数里面就可以修改传入的变量的值了 。
```c
/* 想要修改传入变量的值 ， 则需要使用指针通过变量的地址 ， 来修改变量的值*/
void changeNum(int* num) {
	 printf("函数中i的地址：%#x\n", num);
	*num = 300;
} 

changeNum(&i);

```
输出：
```c
传入函数的 i 的地址：0x4ccff624
函数中i的地址：0x4ccff624
修改后的值：300

```
因为我们传入的是`i`变量的内存地址 ， 所以函数中的`num `变量打印出的就是传入的`i`变量的内存地址 ， 拿到了`i`变量地址 ， 我们就可以通过指针操作传入地址的内存空间了 ， 我们将其修改为`300`  ， 所以我们打出修改后的值是 ： 300 

### 二级指针
所谓的二级指针 ， 就是指针的指针 ， 二级指针的内存空间中 ， 存储的是一级指针的内存地址 ，示例如下：
```c
  
void main() {
	int i = 10;
	// p指针变量存储的是i的内存地址
	int* p = &i;
	// p1指针变量存储的是p的内存地址
	int** p1 = &p;

	int *p2 = 100;

	printf("指针作为普通变量：%d\n", p2);

	printf("i 的地址：%#x\n", &i);

	printf("p 地址：%#x\n", &p);

	printf("通过p1取得p的地址：%#x\n", p1);
	printf("通过p1取得i的地址：%#x\n", *p1);
	printf("通过p1取得i的值：%d\n", **p1);

	// 通过p1修改i的值
	**p1 = 100;

	printf("通过p1修改过的i的值：%d\n", i);

	getchar();
}

```
多级指针 ， 就是要往上一级一级追溯 ， 然后通过`*`操作符来操作内存空间 ，二级指针内存模拟图：

![二级指针.png](http://upload-images.jianshu.io/upload_images/643851-ffca43a8c640a170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



指针是操作内存的神器 ， 多级指针 ， 只要记住 ， 多级指针里面存储的是上级指针的地址即可 。
