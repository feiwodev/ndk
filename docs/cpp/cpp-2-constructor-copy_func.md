### 前情提要
C++是C的拓展语言 ， 加入了面相对象特性，增加了很多函数库 。在C++中 ，提供了引用与指针 ， 这两种变量传递的方式 ， 在C++中 ， 函数参数的传递 ， 一般会使用引用变量传递 ， 因为引用是变量的一个别名 ， 只是叫了另一个名字 ， 就好比我们熟知的诗人“李白”，字“太白” ， 古时，前辈们才能叫我们的名（李白），平辈们只能叫我们的字（李太白） ， 但是不论是叫名还是叫字 ， 都是叫的一个人 ， 那就是诗仙李白 。在C++中 ， 我们只要记住“引用是变量的别名，指针存储的是变量的地址”。引用不申请内存空间，而指针需要内存空间存储地址值。

### 构造函数
在Java中 ， 我们知道 ， 创建一个对象 ， 必定会调用一个构造函数 ， 我们可以在构造函数中 ， 进行一些变量的初始化 ， 做一些创建对象的操作 。 在C++也不列外 ， C++的构造函数特性和Java类似 ， 不论是否重写了构造函数 ， C++在创建对象的时候 ， 都会有一个空的构造函数 。重写了对象的构造函数之后 ， 默认的构造函数就会失效 。 

```c++
public:

	// 构造函数 ， CPP的构造函数与Java的构造函数 ， 特性类似

	// 默认会有一个无参构造函数 ， 在创建对象的时候会被调用

	Product(char* name,char* iconUrl,double price) {

		int strLen = strlen(name);

		// 此处申请内存加1 ， 是因为字符有一个\0的结束符

		this->name = (char*)malloc(strLen+1);

		strcpy(this->name, name);

		this->iconUrl = iconUrl;

		this->price = price;

     }
```
构造函数没什么可说的 ， 特性与Java类似 。

### 析构函数
C++中 ， 没有Java中的GC ， 所以我们只能手动释放 ， 我们在存储数据时所申请的内存空间（动态内存空间） ，  那么 ， 在什么时机回首那些我们申请的内存空间呢 ？  如果回收的内存空间不存在 ， 那么C++就会抛异常中断 。 所以需要有一个地方 ， 方便我们统一释放申请的内存空间 ， 那就是析构函数 。

```c++
// 析构函数 
// 析构函数 ， 在对象使用结束之前调用，是最后执行的函数
// 可以在析构函数里面做对象收尾的工作 ， 比如：动态内存回收
// 析构函数和构造函数一样 ， 会被默认调用
~Product()
{
	cout << "析构函数" << endl;
	// 释放this->name 的动态内存空间
	free(this->name);
}
```
析构函数会在对象使用完之后调用 ， 所以我们可以在析构函数中 ， 释放我们申请的内存空间 ， 这样就不会造成内存空间过多使用 ， 而造成内存溢出 。

### 拷贝构造函数
在Java中 ， 我们如果需要一个等同的对象数据 ， 可以使用`Object.clone()`方法来拷贝（深拷贝）一个对象数据 ， 它会生成一个新的对象 ， 而对象的里面的数据 ， 是和拷贝的对象数据是一致的 。在C++中 ， 则使用使用`ClassType obj; ClassType obj1 = obj;`来进行对象拷贝的 ， `obj1`会生成一个新的对象 。C++中 ， 有一个默认的拷贝函数 ， 这个拷贝函数是值拷贝 ， 并不会完完整整的将`obj`中的内存空间也拷贝进去 。如果我们在构造方法中申请了动态内存 ， 则使用默认的拷贝的函数会出错 ，所以需要重写拷贝函数 。

> C++的默认拷贝函数（浅拷贝）

```c++
// 拷贝构造函数 , 默认拷贝构造函数
// 默认拷贝函数 ， 本质是值拷贝
// 如果拷贝变量中 ， 有指向动态内存的 ， 则只会拷贝指向内存空间的值
// 不会拷贝动态内存空间 
Product(const Product &p) {
	this->name = p.name;
	this->iconUrl = p.iconUrl;
	this->price = p.price;
}
```
拷贝构造函数和构造函数类似 ， 只是函数传参不一样 ， 拷贝构造函数传递是一个常量对象引用。C++的默认拷贝函数是浅拷贝 ， 如果在构造函数中申请了内存空间 ， 则需要重写拷贝函数 ，进行深拷贝 。

> 重写拷贝函数（深拷贝）

```c++
// 深拷贝 ， 如果在构造函数中 ， 使用了动态内存
// 则需要在拷贝构造函数中也需要申请一个动态内存
// 让拷贝的对象与被拷贝的对象一致 ， 不然在析构函数中
// 销毁动态内存时会出错
// 
Product(const Product &p) {
    // 如果在构造函数中申请了动态内存，重写拷贝构造函数也需要申请一个动态内存空间
    // 不然回收动态内存空间的时候会报错
	int strLen = strlen(p.name);
	this->name = (char*)malloc(strLen + 1);
	strcpy(this->name, p.name);
	this->iconUrl = p.iconUrl;
	this->price = p.price;

}
```

### 浅拷贝 and 深拷贝 示意图

> 浅拷贝

![浅拷贝](http://upload-images.jianshu.io/upload_images/643851-e3f26319f8041174.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

浅拷贝 ， 回收动态内存空间的时候会抛出中断异常 。

> 深拷贝

![深拷贝](http://upload-images.jianshu.io/upload_images/643851-182a04d970d5456a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

C++中对象销毁时，都会调用析构函数，析构函数中 ， 我们会进行一些内存空间的清理和释放，如果只拷贝了值 ， 没有拷贝内存空间 ，  那么，拷贝对象进行销毁的时候 ， 回收动态内存空间的时候 ， 却没有那个内存空间 ， 则会抛出中断异常 ， 这样我们就需要将对象进行深拷贝 。

### 结语
C++中的析构函数和拷贝构造函数 ， 是在Java没有的 ， 所以我们需要明确这两个函数的特性 ， 如果有PHP编程经验的 ， 就会发现 ， PHP中也会有析构函数 ， 其特性与作用于C++一致  ， 都是用来释放和销毁资源的。使用对象拷贝的时候 ， 需要注意的是 ， 构造函数中有无使用动态内存 ， 如果有则需要重写拷贝构造函数 ， 以防止一个动态内存引起两次回收 ， 造成异常中断 。

### 源码
[Hello_CPP](https://github.com/zhuyongit/Hello_CPP)
