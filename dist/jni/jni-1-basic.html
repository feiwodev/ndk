<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>## 引言 - Android NDK开发之旅</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">Android NDK开发之旅</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../jni/index.html" class="breadcrumb-item">Java与C通信的桥梁-JNI</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../jni/jni-1-basic.html" class="breadcrumb-item">JNI概念及开发流程</a></div><h1 class="article-title">## 引言</h1><div class="article"><p>在学习了C语言基础之后 ，我们简单的了解了C语言编程的一些范式 ， 了解了指针 ， 结构体 ， 联合体 ， 函数 ， 文件IO等等 。我们最终的目的是要学会NDK开发 ， 而NDK开发就离不开我们的JNI技术 。下面 ， 就来开始我们的JNI之旅吧 。</p><h3 id="jni的概念">JNI的概念 <a class="markdownIt-Anchor" href="#jni的概念">#</a></h3><p>JNI全称 Java Native Interface ， java本地化接口 ， 可以通过JNI调用系统提供的API ， 我们知道 ， 不管是linux还是windows亦或是mac os ， 这些操作系统 ， 都是依靠C/C<ins>写出来的 ， 还包括一些汇编语言写的底层硬件驱动 。java和C/C</ins>不同 ， 它不会直接编译成平台机器码，而是编译成虚拟机可以运行的java字节码的.class文件，通过JIT技术即时编译成本地机器码，所以有效率就比不上C/C++代码，JNI技术就解决了这一痛点，下面我们来看看JNI调用示意图：</p><p><img src="http://upload-images.jianshu.io/upload_images/643851-85aeb72da3ec7186.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JNI技术.png"><br>从上图可以得知 ，JNI技术通过JVM调用到各个平台的API ， 虽然JNI可以调用C/C++ ， 但是JNI调用还是比C/C++编写的原生应用还是要慢一点 ， 不过对高性能计算来说 ， 这点算不得什么 ， 享受它的便利 ， 也要承担它的弊端 。</p><h3 id="jni开发流程">JNI开发流程 <a class="markdownIt-Anchor" href="#jni开发流程">#</a></h3><p>因为JNI开发并未涉及到NDK ， 所有我们的开发工具是eclipse and visual studio 。</p><blockquote><p>第一步：编写java本地方法</p></blockquote><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">getStringFromC</span><span class="hljs-params">()</span> </span>;
</code></pre><blockquote><p>第二步：生成.h头文件 ， 需要使用到的java命令是javah</p></blockquote><pre class="hljs"><code># 假定你以配置好java环境
# 在控制台中进入工程src目录
&gt; cd  E:\java_workspace\Hello_JNI\src
&gt; javah com.zeno.jni.HelloJni 
# 需要注意的是 ， com.zeno.jni.HelloJni ， 是全类名， 包名.类名
</code></pre><blockquote><p>第三步：将.h头文件复制到VS的代码文件目录下 ， 在解决方案中的头文件目录-&gt; 右键-&gt; 添加 -&gt; 添加现有项 。 将我们的头文件添加进来。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/643851-82b09b17357b9bf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加头文件.png"><br>添加进来之后 ， 打开我们的头文件 ， 会发现 ， 头文件里面的jni.h这个头文件找不到 ， 因为它不是系统的头文件 ， 所有我们需要将它找出来 ， 并复制到我们的工程项目中 。</p><pre class="hljs"><code># JDK 的jni.h头文件目录
D:\Java\jdk1.8.0_60\include\jni.h
# 在jni.h头文件中，又引入了jni_md.h头文件 ， 所有这个我们也要一并赋值过来
D:\Java\jdk1.8.0_60\include\win32\jni_md.h
</code></pre><p>将jni.h这个头文件按照上述步骤 ， 添加到头文件目录中 ， 注意将<code>&lt;&gt;</code>改成<code>&quot; &quot;</code> ， <code>&lt;&gt;</code>表示引入的是系统头文件，<code>&quot; &quot;</code>表示引入的是第三方头文件。</p><blockquote><p>第四步：实现头文件</p></blockquote><pre class="hljs"><code><span class="hljs-comment">// 生成的头文件函数</span>
<span class="hljs-comment">/*
 * Class:     com_zeno_jni_HelloJni
 * Method:    getStringFormC
 * Signature: ()Ljava/lang/String;
 */</span>
<span class="hljs-function">JNIEXPORT jstring JNICALL <span class="hljs-title">Java_com_zeno_jni_HelloJni_getStringFromC</span>
  <span class="hljs-params">(JNIEnv *, jclass)</span></span>;
</code></pre><p>新建一个.c的文件 ，引入我们生成的头文件 ，然后实现我们生成的C语言函数。</p><pre class="hljs"><code><span class="hljs-comment">/*
* Class:     com_zeno_jni_HelloJni
* Method:    getStringFormC
* Signature: ()Ljava/lang/String;
*/</span>
<span class="hljs-function">JNIEXPORT jstring JNICALL <span class="hljs-title">Java_com_zeno_jni_HelloJni_getStringFromC</span>
<span class="hljs-params">(JNIEnv *Env, jclass jclazz)</span> </span>{

	<span class="hljs-keyword">return</span> (*Env)-&gt;NewStringUTF(Env, <span class="hljs-string">"Jni C String"</span>);
}
</code></pre><blockquote><p>第五步：生成动态链接库</p></blockquote><p>补充：</p><table><thead><tr><th style="text-align:center">库名称</th><th style="text-align:center">特性</th><th style="text-align:center">扩展名</th></tr></thead><tbody><tr><td style="text-align:center">动态库</td><td style="text-align:center">1.动态库把对一些库函数的链接载入推迟到程序运行的时期。2.可以实现进程之间的资源共享。（因此动态库也称为共享库）3.可以动态注入到程序中</td><td style="text-align:center">win(.dll)linux(.so)</td></tr><tr><td style="text-align:center">静态库</td><td style="text-align:center">1.静态库对函数库的链接是放在编译时期完成的。2.程序在运行时与函数库再无瓜葛，移植方便。3.浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</td><td style="text-align:center">win(.lib)linux(.a)</td></tr></tbody></table><p>了解了静态库和动态库 ， 下面我们就来生成一个动态库，以VS为例：</p><pre class="hljs"><code>选中项目 -&gt; 右键 -&gt; 属性 -&gt; 常规 -&gt; 项目默认值 -&gt; 配置类型 , 选择动态库.dll
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/643851-67d792e8e33cd464.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目属性配置.png"><br>配置完成之后 ， 选中项目 -&gt; 生成 。即可生成动态链接库。</p><figure><img src="http://upload-images.jianshu.io/upload_images/643851-c79d3f871eaf3fe2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动态链接库.png"><figcaption>动态链接库.png</figcaption></figure><blockquote><p>第六步：配置环境变量</p></blockquote><p>我们生成了.dll文件之后 ， java环境并不知道有这个.dll动态链接库的存在 ， 所有我们需要将生成.dll的文件目录 ， 配置到环境变量中。</p><figure><img src="http://upload-images.jianshu.io/upload_images/643851-364610d1de8c1d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置环境变量.png"><figcaption>配置环境变量.png</figcaption></figure><h3 id="注意：配置好环境变量-，-需要重新启动eclipse-，不然会找不到动态链接库的。">注意：配置好环境变量 ， 需要重新启动eclipse ，不然会找不到动态链接库的。 <a class="markdownIt-Anchor" href="#注意：配置好环境变量-，-需要重新启动eclipse-，不然会找不到动态链接库的。">#</a></h3><blockquote><p>第七步：加载动态链接库</p></blockquote><pre class="hljs"><code><span class="hljs-keyword">static</span>{
		System.loadLibrary(<span class="hljs-string">"Hello_JNI"</span>) ;
	}
</code></pre><blockquote><p>第八步 ： 调用本地方法并执行</p></blockquote><pre class="hljs"><code><span class="hljs-comment">/**
 * 
 * <span class="hljs-doctag">@author</span> Zeno
 *
 *	JNI (Java Native Interface) java本地化接口
 *	
 *	Android Framework层与Native层相互通信的基石
 *	
 *
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloJni</span> </span>{
    <span class="hljs-comment">// java调用C/C++函数的本地方法</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">getStringFromC</span><span class="hljs-params">()</span> </span>;
	
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		
		System.out.println(<span class="hljs-string">"getStringFormC == "</span>+getStringFromC());
	}
	
	<span class="hljs-keyword">static</span>{
        <span class="hljs-comment">// 加载动态库</span>
		System.loadLibrary(<span class="hljs-string">"Hello_JNI"</span>) ;
	}
}
</code></pre><p>输出：</p><pre class="hljs"><code>getStringFormC == Jni C String
</code></pre><p>JNI 开发的步骤虽然多 ， 但大多比较简单 ， 操作起来不难 。</p><h3 id="结语">结语 <a class="markdownIt-Anchor" href="#结语">#</a></h3><p>这篇是JNI系列的开篇 ， 总体来说比较简单 ， 先将流程走顺了 ， 后续的开发就会好很多 ， 流程性的东西 ， 需要多操作 ， 就会形成固定的套路 。</p></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../jni/index.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../jni/jni-2-h-file.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.15</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../c/index.html">C语言基础</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../c/c-1-basic.html">基础语法</a></li><li class="chapter-item"><a href="../c/c-2-pointer.html">指针内存分析</a></li><li class="chapter-item"><a href="../c/c-3-func-2pointer.html">函数与二级指针</a></li><li class="chapter-item"><a href="../c/c-4-func-pointer.html">函数指针</a></li><li class="chapter-item"><a href="../c/c-5-dynamic-m.html">动态内存分配</a></li><li class="chapter-item"><a href="../c/c-6-str-op.html">字符操作</a></li><li class="chapter-item"><a href="../c/c-7-struct-pointer.html">结构体与指针</a></li><li class="chapter-item"><a href="../c/c-8-file-io.html">文件IO</a></li><li class="chapter-item"><a href="../c/c-9-enum.html">联合体与枚举</a></li><li class="chapter-item"><a href="../c/c-10-jni.html">预编译及jni-h分析</a></li></ul><li class="chapter-item"><a href="../cpp/index.html">C++基础</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../cpp/cpp-1-namespace-struct-ref.html">命名空间结构体和引用</a></li><li class="chapter-item"><a href="../cpp/cpp-2-constructor-copy_func.html">构造函数，析构函数，拷贝构造函数</a></li><li class="chapter-item"><a href="../cpp/cpp-3-oop.html">new对象，继承，友元函数，函数的可变参数</a></li><li class="chapter-item"><a href="../cpp/cpp-4-template-exception.html">多态，模板，异常</a></li></ul><li class="chapter-item"><a href="../jni/index.html">Java与C通信的桥梁-JNI</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item chapter-item-current"><a href="../jni/jni-1-basic.html">JNI概念及开发流程</a></li><li class="chapter-item"><a href="../jni/jni-2-h-file.html">头文件分析</a></li><li class="chapter-item"><a href="../jni/jni-3-call-java-field-method.html">C语言调用Java字段与方法</a></li><li class="chapter-item"><a href="../jni/jni-4-call-constructor-method.html">C语言调用构造方法</a></li><li class="chapter-item"><a href="../jni/jni-5-ref-handle.html">对象引用的处理</a></li></ul><li class="chapter-item"><a href="../ndk/index.html">Android NDK编写</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../ndk/ndk-1-as-ndk.html">使用Android-Studio编写NDK</a></li><li class="chapter-item"><a href="../ndk/ndk-2-file-split-join.html">文件加密解密与分割合并</a></li><li class="chapter-item"><a href="../ndk/ndk-3-update-1.html">增量更新之服务器端生成差分包</a></li><li class="chapter-item"><a href="../ndk/ndk-4-update-2.html">增量更新之客户端合并差分包</a></li><li class="chapter-item"><a href="../ndk/ndk-5-conf.html">基于已有项目的NDK环境配置</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"jni/jni-1-basic.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li>\n<ul>\n<li><a href="#jni%E7%9A%84%E6%A6%82%E5%BF%B5">JNI的概念</a></li>\n<li><a href="#jni%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B">JNI开发流程</a></li>\n<li><a href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-%EF%BC%8C-%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8eclipse-%EF%BC%8C%E4%B8%8D%E7%84%B6%E4%BC%9A%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E3%80%82">注意：配置好环境变量 ， 需要重新启动eclipse ，不然会找不到动态链接库的。</a></li>\n<li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>