<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>## 前情提要 - Android NDK开发之旅</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">Android NDK开发之旅</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../jni/index.html" class="breadcrumb-item">Java与C通信的桥梁-JNI</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../jni/jni-2-h-file.html" class="breadcrumb-item">头文件分析</a></div><h1 class="article-title">## 前情提要</h1><div class="article"><p>JNI技术 ， 是java世界与C/C<ins>世界的通信基础 ， java语言可以通过native方法去调用C/C</ins>的函数 ， 也可以通过C/C++来调用java的字段与方法 。 在上篇中 ， 我们了解了JNI开发的基本流程 ， 接下来我们来分析分析C语言代码以及头文件 。</p><h3 id="h头文件分析">.h头文件分析 <a class="markdownIt-Anchor" href="#h头文件分析">#</a></h3><blockquote><p>头文件生成命令 ： javah com.zeno.jni.HelloJni</p></blockquote><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">getStringFromC</span><span class="hljs-params">()</span> </span>;
</code></pre><p>上述代码 通过<code>javah</code>命令 ， 则会生成如下头文件中的函数：</p><pre class="hljs"><code><span class="hljs-comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"jni.h"</span></span>
<span class="hljs-comment">/* Header for class com_zeno_jni_HelloJni */</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _Included_com_zeno_jni_HelloJni</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _Included_com_zeno_jni_HelloJni</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> {
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-comment">/*
 * Class:     com_zeno_jni_HelloJni
 * Method:    getStringFormC
 * Signature: ()Ljava/lang/String;
 */</span>
<span class="hljs-function">JNIEXPORT jstring JNICALL <span class="hljs-title">Java_com_zeno_jni_HelloJni_getStringFromC</span>
  <span class="hljs-params">(JNIEnv *, jclass)</span></span>;

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span>
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre><p>通过上述代码， 我们可以看出<code>getStringFromC()</code>方法 ， 生成的函数是<code>Java_com_zeno_jni_HelloJni_getStringFromC (JNIEnv *, jclass)</code>函数 。其实 ，我们不用<code>javah</code>命令 ， 也能写出头文件 ， 除了<code>#endif,#ifdef __cplusplus</code>中间是变化的 ， 其他的都不变 ， <code>javah</code>通过<code>native</code>方法生成的函数 ， 命名都是有规律 。</p><pre class="hljs"><code>函数名称规则：Java_完整类名_方法名  , 包名的.号 ， 以`_`表示
</code></pre><blockquote><p>其中jstring是返回的java的String类型 ， jstring类型是jni里面定义的类型 ， 标准C里面是没有的 。那么 ， jstring是什么类型呢 ？<br>使用VS的转到定义功能 ， 我们可以看到 , jstring在jni.h的定义 ， jstring是jobject的别名 ， jobject是一个_jobject结构体的指针 。</p></blockquote><pre class="hljs"><code><span class="hljs-keyword">typedef</span> jobject jstring;
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">jobject</span> *<span class="hljs-title">jobject</span>;</span>
</code></pre><p>因为我们<code>getStringFromC()</code>方法返回的是一个String类型 ， 所以C函数的返回值是<code>jstring</code>类型 。</p><pre class="hljs"><code><span class="hljs-comment">/*
* Class:     com_zeno_jni_HelloJni
* Method:    getStringFormC
* Signature: ()Ljava/lang/String;
*/</span>
<span class="hljs-function">JNIEXPORT jstring JNICALL <span class="hljs-title">Java_com_zeno_jni_HelloJni_getStringFromC</span>
<span class="hljs-params">(JNIEnv *Env, jclass jclazz)</span> </span>{

	<span class="hljs-keyword">return</span> (*Env)-&gt;NewStringUTF(Env, <span class="hljs-string">"Jni C String"</span>);
}
</code></pre><p>在C语言系列的最后一篇 ， 我们分析了jni.h的头文件 ， 了解了JNIEnv结构体指针 ， 大致知道里面都有些什么函数 ， <code>NewStringUTF(Env, &quot;Jni C String&quot;)</code>这个函数 ， 就是将C语言中的字符指针转换成java的<code>String</code>类型的字符串。</p><h3 id="jni数据类型对应java的标准数据类型">JNI数据类型对应java的标准数据类型 <a class="markdownIt-Anchor" href="#jni数据类型对应java的标准数据类型">#</a></h3><table><thead><tr><th style="text-align:center">Java Type</th><th style="text-align:center">Native Type</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center">jboolean</td><td style="text-align:center">unsigned 8 bits</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">jbyte</td><td style="text-align:center">signed 8 bits</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">jchar</td><td style="text-align:center">unsigned 16 bits</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">jshort</td><td style="text-align:center">signed 16 bits</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">jint</td><td style="text-align:center">signed 32 bits</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">jlong</td><td style="text-align:center">signed 64 bits</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">jfloat</td><td style="text-align:center">32 bits</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">jdouble</td><td style="text-align:center">64 bits</td></tr><tr><td style="text-align:center">void</td><td style="text-align:center">void</td><td style="text-align:center">not applicable</td></tr></tbody></table><h3 id="jni数据类型对应java的引用数据类型">JNI数据类型对应java的引用数据类型 <a class="markdownIt-Anchor" href="#jni数据类型对应java的引用数据类型">#</a></h3><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">jobject</span>;</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">jobject</span> *<span class="hljs-title">jobject</span>;</span>
<span class="hljs-keyword">typedef</span> jobject jclass;
<span class="hljs-keyword">typedef</span> jobject jthrowable;
<span class="hljs-keyword">typedef</span> jobject jstring;
<span class="hljs-keyword">typedef</span> jobject jarray;
<span class="hljs-keyword">typedef</span> jarray jbooleanArray;
<span class="hljs-keyword">typedef</span> jarray jbyteArray;
<span class="hljs-keyword">typedef</span> jarray jcharArray;
<span class="hljs-keyword">typedef</span> jarray jshortArray;
<span class="hljs-keyword">typedef</span> jarray jintArray;
<span class="hljs-keyword">typedef</span> jarray jlongArray;
<span class="hljs-keyword">typedef</span> jarray jfloatArray;
<span class="hljs-keyword">typedef</span> jarray jdoubleArray;
<span class="hljs-keyword">typedef</span> jarray jobjectArray;
</code></pre><p>在jni源码中 ， 我们可以看到如上定义 ， 可以发现 ， 所有的引用类型都是<code>_jobject</code>结构体指针类型。</p><h3 id="jnienv分析">JNIEnv分析 <a class="markdownIt-Anchor" href="#jnienv分析">#</a></h3><p>我们知道 ，JNIEnv是<code>JNINativeInterface_</code>结构体的指针别名 ， 在<code>JNINativeInterface_</code>结构体中 ， 定义很多操作函数 。例如：</p><pre class="hljs"><code>jstring (JNICALL *NewStringUTF) (JNIEnv *env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *utf);
jsize (JNICALL *GetStringUTFLength) (JNIEnv *env, jstring str);
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* (JNICALL *GetStringUTFChars)(JNIEnv *env, jstring str, jboolean *isCopy);
 <span class="hljs-keyword">void</span> (JNICALL *ReleaseStringUTFChars)(JNIEnv *env, jstring str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* chars);
</code></pre><p>由上述函数可以看出，每个函数都需要一个JNIEnv指针，但是为什么需要呢 ？</p><blockquote><p>有两点：<br>第一：函数需要 , 在函数中仍然需要JNINativeInterface_结构体中的函数做处理<br>第二：区别对待C和C++<br>我们知道 ， jni是支持C/C<ins>的，在jni.h头文件中 ， 那么C</ins>是怎么表示JNIEnv的呢 ？源码如下：</p></blockquote><pre class="hljs"><code> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JNIEnv_</span> {</span>
    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JNINativeInterface_</span> *<span class="hljs-title">functions</span>;</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span>

    <span class="hljs-function">jint <span class="hljs-title">GetVersion</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> functions-&gt;GetVersion(<span class="hljs-keyword">this</span>);
    }
    <span class="hljs-function">jclass <span class="hljs-title">DefineClass</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, jobject loader, <span class="hljs-keyword">const</span> jbyte *buf,
                       jsize len)</span> </span>{
        <span class="hljs-keyword">return</span> functions-&gt;DefineClass(<span class="hljs-keyword">this</span>, name, loader, buf, len);
    }
    <span class="hljs-function">jclass <span class="hljs-title">FindClass</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span> </span>{
        <span class="hljs-keyword">return</span> functions-&gt;FindClass(<span class="hljs-keyword">this</span>, name);
    }
    <span class="hljs-function">jmethodID <span class="hljs-title">FromReflectedMethod</span><span class="hljs-params">(jobject method)</span> </span>{
        <span class="hljs-keyword">return</span> functions-&gt;FromReflectedMethod(<span class="hljs-keyword">this</span>,method);
    }
</code></pre><p>在C<ins>环境下 ，还是使用的<code>NINativeInterface_</code>结构体指针调用函数， 使用<code>NewStringUTF</code>函数时， 则不需要传入<code>Env</code>这个二级指针 ，因为C</ins>是面向对象的语言 ， 传入了this ， 当前环境的指针</p><pre class="hljs"><code><span class="hljs-function">jstring <span class="hljs-title">NewStringUTF</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *utf)</span> </span>{
        <span class="hljs-keyword">return</span> functions-&gt;NewStringUTF(<span class="hljs-keyword">this</span>,utf);
    }
</code></pre><p>示例：</p><pre class="hljs"><code><span class="hljs-comment">/*
* Class:     com_zeno_jni_HelloJni
* Method:    getStringFormC
* Signature: ()Ljava/lang/String;
*/</span>
<span class="hljs-function">JNIEXPORT jstring JNICALL <span class="hljs-title">Java_com_zeno_jni_HelloJni_getStringFromCPP</span>
<span class="hljs-params">(JNIEnv * env, jclass jclazz)</span> </span>{

	<span class="hljs-keyword">return</span> env-&gt;NewStringUTF(<span class="hljs-string">"From C++ String"</span>);
}
</code></pre><p>在C++环境中 ， JNIEnv就成了一级指针了 ， 为什么会是这样呢 ？我们在源码中找到这样一段代码：</p><pre class="hljs"><code><span class="hljs-comment">/*
 * JNI Native Method Interface.
 */</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JNINativeInterface_</span>;</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JNIEnv_</span>;</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span>
<span class="hljs-keyword">typedef</span> JNIEnv_ JNIEnv;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JNINativeInterface_</span> *<span class="hljs-title">JNIEnv</span>;</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre><p>由上可知 ， 在C和C++两个环境中 ， 使用了两个不同的JNIEnv ， 一个是JNIEnv二级指针 ， 一个是JNIEnv一级指针 。</p><h3 id="模拟c语言中的jnienv写法">模拟C语言中的JNIEnv写法 <a class="markdownIt-Anchor" href="#模拟c语言中的jnienv写法">#</a></h3><pre class="hljs"><code>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-comment">// 定义一个JNIEnv , 是JavaNativeInterface结构体指针的别名</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JavaNativeInterface</span>* <span class="hljs-title">JNIEnv</span>;</span>

<span class="hljs-comment">// 模拟java本地化接口结构体</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JavaNativeInterface</span> {</span>
	<span class="hljs-keyword">void</span>(*hadlefunc)(JNIEnv*);
	<span class="hljs-keyword">char</span>*(*NewStringUTF)(JNIEnv*, <span class="hljs-keyword">char</span>*);
};

<span class="hljs-comment">// 模拟 ， 在调用NewStringUTF函数的时候 ， 需要处理一些事情</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleFunction</span><span class="hljs-params">(JNIEnv* env)</span> </span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"正在处理...\n"</span>);
}

<span class="hljs-comment">// 最终调用的函数实现</span>
<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">NewStringUTF</span><span class="hljs-params">(JNIEnv* env,<span class="hljs-keyword">char</span>* utf)</span> </span>{
	
	(*env)-&gt;hadlefunc(env);

	<span class="hljs-keyword">return</span> utf;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
	<span class="hljs-comment">//实例化结构体</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JavaNativeInterface</span> <span class="hljs-title">jnf</span>;</span>
	jnf.hadlefunc = handleFunction;
	jnf.NewStringUTF = NewStringUTF;
	<span class="hljs-comment">// 结构体指针</span>
	JNIEnv e = &amp;jnf;
	<span class="hljs-comment">// 二级指针</span>
	JNIEnv* env = &amp;e;

	<span class="hljs-comment">// 通过二级指针掉用函数</span>
	<span class="hljs-keyword">char</span>* res = (*env)-&gt;NewStringUTF(env, <span class="hljs-string">"模拟JNIEnv实现方式\n"</span>);

	<span class="hljs-comment">// 打印</span>
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"调用结果：%s"</span>, res);

	system(<span class="hljs-string">"pause"</span>);
}
</code></pre><p>输出：</p><pre class="hljs"><code>正在处理...
调用结果：模拟JNIEnv实现方式
</code></pre><p>###结语<br>.h头文件的分析就到这里 ，关键是了解清楚 ， <code>native</code>方法在C中生成函数名称的规则 ， 以及对JNIEnv有个良好的认识 。</p><p>参考文献：<br>[<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html" target="_blank" rel="noopener">Java Native Interface 6.0 Specification</a> ](<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html</a>)</p></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../jni/jni-1-basic.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../jni/jni-3-call-java-field-method.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.15</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../c/index.html">C语言基础</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../c/c-1-basic.html">基础语法</a></li><li class="chapter-item"><a href="../c/c-2-pointer.html">指针内存分析</a></li><li class="chapter-item"><a href="../c/c-3-func-2pointer.html">函数与二级指针</a></li><li class="chapter-item"><a href="../c/c-4-func-pointer.html">函数指针</a></li><li class="chapter-item"><a href="../c/c-5-dynamic-m.html">动态内存分配</a></li><li class="chapter-item"><a href="../c/c-6-str-op.html">字符操作</a></li><li class="chapter-item"><a href="../c/c-7-struct-pointer.html">结构体与指针</a></li><li class="chapter-item"><a href="../c/c-8-file-io.html">文件IO</a></li><li class="chapter-item"><a href="../c/c-9-enum.html">联合体与枚举</a></li><li class="chapter-item"><a href="../c/c-10-jni.html">预编译及jni-h分析</a></li></ul><li class="chapter-item"><a href="../cpp/index.html">C++基础</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../cpp/cpp-1-namespace-struct-ref.html">命名空间结构体和引用</a></li><li class="chapter-item"><a href="../cpp/cpp-2-constructor-copy_func.html">构造函数，析构函数，拷贝构造函数</a></li><li class="chapter-item"><a href="../cpp/cpp-3-oop.html">new对象，继承，友元函数，函数的可变参数</a></li><li class="chapter-item"><a href="../cpp/cpp-4-template-exception.html">多态，模板，异常</a></li></ul><li class="chapter-item"><a href="../jni/index.html">Java与C通信的桥梁-JNI</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../jni/jni-1-basic.html">JNI概念及开发流程</a></li><li class="chapter-item chapter-item-current"><a href="../jni/jni-2-h-file.html">头文件分析</a></li><li class="chapter-item"><a href="../jni/jni-3-call-java-field-method.html">C语言调用Java字段与方法</a></li><li class="chapter-item"><a href="../jni/jni-4-call-constructor-method.html">C语言调用构造方法</a></li><li class="chapter-item"><a href="../jni/jni-5-ref-handle.html">对象引用的处理</a></li></ul><li class="chapter-item"><a href="../ndk/index.html">Android NDK编写</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../ndk/ndk-1-as-ndk.html">使用Android-Studio编写NDK</a></li><li class="chapter-item"><a href="../ndk/ndk-2-file-split-join.html">文件加密解密与分割合并</a></li><li class="chapter-item"><a href="../ndk/ndk-3-update-1.html">增量更新之服务器端生成差分包</a></li><li class="chapter-item"><a href="../ndk/ndk-4-update-2.html">增量更新之客户端合并差分包</a></li><li class="chapter-item"><a href="../ndk/ndk-5-conf.html">基于已有项目的NDK环境配置</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"jni/jni-2-h-file.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li>\n<ul>\n<li><a href="#h%E5%A4%B4%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90">.h头文件分析</a></li>\n<li><a href="#jni%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94java%E7%9A%84%E6%A0%87%E5%87%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">JNI数据类型对应java的标准数据类型</a></li>\n<li><a href="#jni%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94java%E7%9A%84%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">JNI数据类型对应java的引用数据类型</a></li>\n<li><a href="#jnienv%E5%88%86%E6%9E%90">JNIEnv分析</a></li>\n<li><a href="#%E6%A8%A1%E6%8B%9Fc%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84jnienv%E5%86%99%E6%B3%95">模拟C语言中的JNIEnv写法</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>