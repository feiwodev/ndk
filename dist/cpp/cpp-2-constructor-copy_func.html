<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>## 前情提要 - Android NDK开发之旅</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">Android NDK开发之旅</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../cpp/index.html" class="breadcrumb-item">C++基础</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../cpp/cpp-2-constructor-copy_func.html" class="breadcrumb-item">构造函数，析构函数，拷贝构造函数</a></div><h1 class="article-title">## 前情提要</h1><div class="article"><p>C<ins>是C的拓展语言 ， 加入了面相对象特性，增加了很多函数库 。在C</ins>中 ，提供了引用与指针 ， 这两种变量传递的方式 ， 在C<ins>中 ， 函数参数的传递 ， 一般会使用引用变量传递 ， 因为引用是变量的一个别名 ， 只是叫了另一个名字 ， 就好比我们熟知的诗人“李白”，字“太白” ， 古时，前辈们才能叫我们的名（李白），平辈们只能叫我们的字（李太白） ， 但是不论是叫名还是叫字 ， 都是叫的一个人 ， 那就是诗仙李白 。在C</ins>中 ， 我们只要记住“引用是变量的别名，指针存储的是变量的地址”。引用不申请内存空间，而指针需要内存空间存储地址值。</p><h3 id="构造函数">构造函数 <a class="markdownIt-Anchor" href="#构造函数">#</a></h3><p>在Java中 ， 我们知道 ， 创建一个对象 ， 必定会调用一个构造函数 ， 我们可以在构造函数中 ， 进行一些变量的初始化 ， 做一些创建对象的操作 。 在C<ins>也不列外 ， C</ins>的构造函数特性和Java类似 ， 不论是否重写了构造函数 ， C++在创建对象的时候 ， 都会有一个空的构造函数 。重写了对象的构造函数之后 ， 默认的构造函数就会失效 。</p><pre class="hljs"><code><span class="hljs-keyword">public</span>:

	<span class="hljs-comment">// 构造函数 ， CPP的构造函数与Java的构造函数 ， 特性类似</span>

	<span class="hljs-comment">// 默认会有一个无参构造函数 ， 在创建对象的时候会被调用</span>

	Product(<span class="hljs-keyword">char</span>* name,<span class="hljs-keyword">char</span>* iconUrl,<span class="hljs-keyword">double</span> price) {

		<span class="hljs-keyword">int</span> strLen = <span class="hljs-built_in">strlen</span>(name);

		<span class="hljs-comment">// 此处申请内存加1 ， 是因为字符有一个\0的结束符</span>

		<span class="hljs-keyword">this</span>-&gt;name = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(strLen+<span class="hljs-number">1</span>);

		<span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;name, name);

		<span class="hljs-keyword">this</span>-&gt;iconUrl = iconUrl;

		<span class="hljs-keyword">this</span>-&gt;price = price;

     }
</code></pre><p>构造函数没什么可说的 ， 特性与Java类似 。</p><h3 id="析构函数">析构函数 <a class="markdownIt-Anchor" href="#析构函数">#</a></h3><p>C<ins>中 ， 没有Java中的GC ， 所以我们只能手动释放 ， 我们在存储数据时所申请的内存空间（动态内存空间） ， 那么 ， 在什么时机回首那些我们申请的内存空间呢 ？ 如果回收的内存空间不存在 ， 那么C</ins>就会抛异常中断 。 所以需要有一个地方 ， 方便我们统一释放申请的内存空间 ， 那就是析构函数 。</p><pre class="hljs"><code><span class="hljs-comment">// 析构函数 </span>
<span class="hljs-comment">// 析构函数 ， 在对象使用结束之前调用，是最后执行的函数</span>
<span class="hljs-comment">// 可以在析构函数里面做对象收尾的工作 ， 比如：动态内存回收</span>
<span class="hljs-comment">// 析构函数和构造函数一样 ， 会被默认调用</span>
~Product()
{
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"析构函数"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
	<span class="hljs-comment">// 释放this-&gt;name 的动态内存空间</span>
	<span class="hljs-built_in">free</span>(<span class="hljs-keyword">this</span>-&gt;name);
}
</code></pre><p>析构函数会在对象使用完之后调用 ， 所以我们可以在析构函数中 ， 释放我们申请的内存空间 ， 这样就不会造成内存空间过多使用 ， 而造成内存溢出 。</p><h3 id="拷贝构造函数">拷贝构造函数 <a class="markdownIt-Anchor" href="#拷贝构造函数">#</a></h3><p>在Java中 ， 我们如果需要一个等同的对象数据 ， 可以使用<code>Object.clone()</code>方法来拷贝（深拷贝）一个对象数据 ， 它会生成一个新的对象 ， 而对象的里面的数据 ， 是和拷贝的对象数据是一致的 。在C<ins>中 ， 则使用使用<code>ClassType obj; ClassType obj1 = obj;</code>来进行对象拷贝的 ， <code>obj1</code>会生成一个新的对象 。C</ins>中 ， 有一个默认的拷贝函数 ， 这个拷贝函数是值拷贝 ， 并不会完完整整的将<code>obj</code>中的内存空间也拷贝进去 。如果我们在构造方法中申请了动态内存 ， 则使用默认的拷贝的函数会出错 ，所以需要重写拷贝函数 。</p><blockquote><p>C++的默认拷贝函数（浅拷贝）</p></blockquote><pre class="hljs"><code><span class="hljs-comment">// 拷贝构造函数 , 默认拷贝构造函数</span>
<span class="hljs-comment">// 默认拷贝函数 ， 本质是值拷贝</span>
<span class="hljs-comment">// 如果拷贝变量中 ， 有指向动态内存的 ， 则只会拷贝指向内存空间的值</span>
<span class="hljs-comment">// 不会拷贝动态内存空间 </span>
Product(<span class="hljs-keyword">const</span> Product &amp;p) {
	<span class="hljs-keyword">this</span>-&gt;name = p.name;
	<span class="hljs-keyword">this</span>-&gt;iconUrl = p.iconUrl;
	<span class="hljs-keyword">this</span>-&gt;price = p.price;
}
</code></pre><p>拷贝构造函数和构造函数类似 ， 只是函数传参不一样 ， 拷贝构造函数传递是一个常量对象引用。C++的默认拷贝函数是浅拷贝 ， 如果在构造函数中申请了内存空间 ， 则需要重写拷贝函数 ，进行深拷贝 。</p><blockquote><p>重写拷贝函数（深拷贝）</p></blockquote><pre class="hljs"><code><span class="hljs-comment">// 深拷贝 ， 如果在构造函数中 ， 使用了动态内存</span>
<span class="hljs-comment">// 则需要在拷贝构造函数中也需要申请一个动态内存</span>
<span class="hljs-comment">// 让拷贝的对象与被拷贝的对象一致 ， 不然在析构函数中</span>
<span class="hljs-comment">// 销毁动态内存时会出错</span>
<span class="hljs-comment">// </span>
Product(<span class="hljs-keyword">const</span> Product &amp;p) {
    <span class="hljs-comment">// 如果在构造函数中申请了动态内存，重写拷贝构造函数也需要申请一个动态内存空间</span>
    <span class="hljs-comment">// 不然回收动态内存空间的时候会报错</span>
	<span class="hljs-keyword">int</span> strLen = <span class="hljs-built_in">strlen</span>(p.name);
	<span class="hljs-keyword">this</span>-&gt;name = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(strLen + <span class="hljs-number">1</span>);
	<span class="hljs-built_in">strcpy</span>(<span class="hljs-keyword">this</span>-&gt;name, p.name);
	<span class="hljs-keyword">this</span>-&gt;iconUrl = p.iconUrl;
	<span class="hljs-keyword">this</span>-&gt;price = p.price;

}
</code></pre><h3 id="浅拷贝-and-深拷贝-示意图">浅拷贝 and 深拷贝 示意图 <a class="markdownIt-Anchor" href="#浅拷贝-and-深拷贝-示意图">#</a></h3><blockquote><p>浅拷贝</p></blockquote><figure><img src="http://upload-images.jianshu.io/upload_images/643851-e3f26319f8041174.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浅拷贝"><figcaption>浅拷贝</figcaption></figure><p>浅拷贝 ， 回收动态内存空间的时候会抛出中断异常 。</p><blockquote><p>深拷贝</p></blockquote><figure><img src="http://upload-images.jianshu.io/upload_images/643851-182a04d970d5456a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="深拷贝"><figcaption>深拷贝</figcaption></figure><p>C++中对象销毁时，都会调用析构函数，析构函数中 ， 我们会进行一些内存空间的清理和释放，如果只拷贝了值 ， 没有拷贝内存空间 ， 那么，拷贝对象进行销毁的时候 ， 回收动态内存空间的时候 ， 却没有那个内存空间 ， 则会抛出中断异常 ， 这样我们就需要将对象进行深拷贝 。</p><h3 id="结语">结语 <a class="markdownIt-Anchor" href="#结语">#</a></h3><p>C<ins>中的析构函数和拷贝构造函数 ， 是在Java没有的 ， 所以我们需要明确这两个函数的特性 ， 如果有PHP编程经验的 ， 就会发现 ， PHP中也会有析构函数 ， 其特性与作用于C</ins>一致 ， 都是用来释放和销毁资源的。使用对象拷贝的时候 ， 需要注意的是 ， 构造函数中有无使用动态内存 ， 如果有则需要重写拷贝构造函数 ， 以防止一个动态内存引起两次回收 ， 造成异常中断 。</p><h3 id="源码">源码 <a class="markdownIt-Anchor" href="#源码">#</a></h3><p><a href="https://github.com/zhuyongit/Hello_CPP" target="_blank" rel="noopener">Hello_CPP</a></p></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../cpp/cpp-1-namespace-struct-ref.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../cpp/cpp-3-oop.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.15</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../c/index.html">C语言基础</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../c/c-1-basic.html">基础语法</a></li><li class="chapter-item"><a href="../c/c-2-pointer.html">指针内存分析</a></li><li class="chapter-item"><a href="../c/c-3-func-2pointer.html">函数与二级指针</a></li><li class="chapter-item"><a href="../c/c-4-func-pointer.html">函数指针</a></li><li class="chapter-item"><a href="../c/c-5-dynamic-m.html">动态内存分配</a></li><li class="chapter-item"><a href="../c/c-6-str-op.html">字符操作</a></li><li class="chapter-item"><a href="../c/c-7-struct-pointer.html">结构体与指针</a></li><li class="chapter-item"><a href="../c/c-8-file-io.html">文件IO</a></li><li class="chapter-item"><a href="../c/c-9-enum.html">联合体与枚举</a></li><li class="chapter-item"><a href="../c/c-10-jni.html">预编译及jni-h分析</a></li></ul><li class="chapter-item"><a href="../cpp/index.html">C++基础</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../cpp/cpp-1-namespace-struct-ref.html">命名空间结构体和引用</a></li><li class="chapter-item chapter-item-current"><a href="../cpp/cpp-2-constructor-copy_func.html">构造函数，析构函数，拷贝构造函数</a></li><li class="chapter-item"><a href="../cpp/cpp-3-oop.html">new对象，继承，友元函数，函数的可变参数</a></li><li class="chapter-item"><a href="../cpp/cpp-4-template-exception.html">多态，模板，异常</a></li></ul><li class="chapter-item"><a href="../jni/index.html">Java与C通信的桥梁-JNI</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../jni/jni-1-basic.html">JNI概念及开发流程</a></li><li class="chapter-item"><a href="../jni/jni-2-h-file.html">头文件分析</a></li><li class="chapter-item"><a href="../jni/jni-3-call-java-field-method.html">C语言调用Java字段与方法</a></li><li class="chapter-item"><a href="../jni/jni-4-call-constructor-method.html">C语言调用构造方法</a></li><li class="chapter-item"><a href="../jni/jni-5-ref-handle.html">对象引用的处理</a></li></ul><li class="chapter-item"><a href="../ndk/index.html">Android NDK编写</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../ndk/ndk-1-as-ndk.html">使用Android-Studio编写NDK</a></li><li class="chapter-item"><a href="../ndk/ndk-2-file-split-join.html">文件加密解密与分割合并</a></li><li class="chapter-item"><a href="../ndk/ndk-3-update-1.html">增量更新之服务器端生成差分包</a></li><li class="chapter-item"><a href="../ndk/ndk-4-update-2.html">增量更新之客户端合并差分包</a></li><li class="chapter-item"><a href="../ndk/ndk-5-conf.html">基于已有项目的NDK环境配置</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"cpp/cpp-2-constructor-copy_func.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li>\n<ul>\n<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></li>\n<li><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">析构函数</a></li>\n<li><a href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">拷贝构造函数</a></li>\n<li><a href="#%E6%B5%85%E6%8B%B7%E8%B4%9D-and-%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E7%A4%BA%E6%84%8F%E5%9B%BE">浅拷贝 and 深拷贝 示意图</a></li>\n<li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li>\n<li><a href="#%E6%BA%90%E7%A0%81">源码</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>