<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>## 前情提要 - Android NDK开发之旅</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">Android NDK开发之旅</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../ndk/index.html" class="breadcrumb-item">Android NDK编写</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../ndk/ndk-3-update-1.html" class="breadcrumb-item">增量更新之服务器端生成差分包</a></div><h1 class="article-title">## 前情提要</h1><div class="article"><p>IO操作 ， 一直在开发中占据很大比重 ， 在Java中不管是网络操作还是文件操作 ， 都作为IO流来处理 ， 都依靠<code>InputStream</code>和<code>OutputStream</code>这两个输入输出流 。在上篇中 ， 使用了C语言的IO流 ， 进行了文件的加密与解密，分割与合并 。其要点是，加密解密使用了<code>^</code>运算 ，分割文件则使用了，文件大小与文件个数的<code>%</code>运算 。</p><h3 id="为什么需要增量更新？">为什么需要增量更新？ <a class="markdownIt-Anchor" href="#为什么需要增量更新？">#</a></h3><p>当我们开发完一个项目之后，上线维护 ， 增加新功能 ， 添加第三方库 ， APK大小从4 - 5M ， 增长到10+M ， 用户由原来的几十秒下载 ， 到现在几分钟以上的下载 ， 网络情况不好的时候 ， 或许就是十分钟不等。每次全量下载 ， 无论从体验还是流量上 ， 都是不友好的 ， 所有增量更新还是有必要的 （小公司好像没几个用 ， 一般大公司在用，如QQ空间）。</p><h3 id="增量原理（图）">增量原理（图） <a class="markdownIt-Anchor" href="#增量原理（图）">#</a></h3><figure><img src="http://upload-images.jianshu.io/upload_images/643851-3a5a218a1c04ab11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="差分包原理图"><figcaption>差分包原理图</figcaption></figure><p>bsdiff 进行文件内容比较，并且使用了bzip2进行文件压缩 ， 所有得出的差分包可能比理论值要小 ， 进一步可以减少用户流量 。增量更新 ， 较为关键的部分就是生成差分包 ， 将新旧APK进行比较 ， 生成一个新的文件 。</p><h3 id="生产资源及工具">生产资源及工具 <a class="markdownIt-Anchor" href="#生产资源及工具">#</a></h3><p>bsdiff --- <a href="http://sites.inka.de/tesla/download/bsdiff4.3-win32-src.zip" target="_blank" rel="noopener">bsdiff （win环境） </a>生成差分包及合并差分包库 ， 源码内已包含bzip2<br>bzip2 --- <a href="http://www.bzip.org/downloads.html" target="_blank" rel="noopener">bzip2</a> bsdiff 依赖<br>服务器 --- <a href="http://tomcat.apache.org/tomcat-7.0-doc/index.html" target="_blank" rel="noopener">Tomcat 7.0 </a>（模拟网络环境）放置差分包 ， 供APP下载<br>开发工具 --- Eclipse NDK开发 ， 目前建议使用Eclipse开发<br>开发工具 --- VS 因为服务器搭建在windows平台 ， 所以使用VS开发JNI，在JNI系列中有使用 ， 不了解的可以前去了解 <a href="http://www.jianshu.com/p/68bca86a84ce" target="_blank" rel="noopener">JNI开发系列①JNI概念及开发流程</a></p><h3 id="编写bsdiff-jni">编写bsdiff JNI <a class="markdownIt-Anchor" href="#编写bsdiff-jni">#</a></h3><p>当我们拿到一个C语言库 ， 首先我该怎么做 ?</p><blockquote><p>首其一 ， 了解其用法 ， 找main函数</p></blockquote><p>下载完bsdiff之后 ， 我们看到如下目录：</p><p><img src="http://upload-images.jianshu.io/upload_images/643851-5f8a8d3811cfa95d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bsdiff win32"><br>看这么多文件 ， 还有一些乱七八糟的不知道什么的文件 ， 那么我们只关注 ， 我们知道的文件 ， 将C/C++源文件以及.h头文件，找出来 ，放到一个干净的文件夹中 。</p><p>创建一个VS项目 ， 将源文件都放入到VS项目目录下 ， 添加现有项目 ， 将源码与项目关联 ， 参考：<a href="http://www.jianshu.com/p/68bca86a84ce" target="_blank" rel="noopener">JNI开发系列①JNI概念及开发流程</a></p><p><strong>找main函数</strong></p><figure><img src="http://upload-images.jianshu.io/upload_images/643851-ccabbd4c4eedac3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="search main func"><figcaption>search main func</figcaption></figure><p>在<code>bsdiff.cpp</code>文件找到带参数的<code>main</code>函数 ， 并且有一个关于用法的线索 ， 那就是：</p><pre class="hljs"><code><span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">4</span>) errx(<span class="hljs-number">1</span>,<span class="hljs-string">"usage: %s oldfile newfile patchfile\n"</span>,argv[<span class="hljs-number">0</span>]);
</code></pre><p>我们可以根据这句话来推测 ， 需要四个参数 ， 并且三个参数必须传入的文件路径 ， 还有一个不知晓 ， 暂且不管它 。</p><blockquote><p>其二 ， 创建JNI方法 ， 修改main函数</p></blockquote><p>既然知道了需要传入的参数 ， 那么就可以创建一个Java工程 ， 编写JNI方法了。</p><pre class="hljs"><code><span class="hljs-comment">/**
 * 生成差分包
 * <span class="hljs-doctag">@param</span> oldFilePath 老版本文件路径
 * <span class="hljs-doctag">@param</span> newFilePath 新版本文件路径
 * <span class="hljs-doctag">@param</span> patchFilePath 生成差分包文件路径
 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">diff</span><span class="hljs-params">(String oldFilePath , String newFilePath , String patchFilePath)</span> </span>;
</code></pre><p>使用<code>javah</code>生成头文件 ， 引入到bsdiff.cpp文件中，编写调用的C函数 ， 并修改<code>main</code>函数名称，<code>main</code>函数作为入口函数 ， 在JNI中就适用了 ， 所有将<code>main</code>函数名称改一下 ， 在JNI的C函数中调用即可 。</p><pre class="hljs"><code><span class="hljs-comment">/*文件差分*/</span>
<span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">Java_com_zeno_bsdiff_BsdiffUtils_diff</span>
<span class="hljs-params">(JNIEnv *env, jclass clazz, jstring joldFilePath, jstring jnewFilePath, jstring jpatchFilePath)</span> </span>{

	<span class="hljs-keyword">char</span>* oldFilePath = (<span class="hljs-keyword">char</span>*)env-&gt;GetStringUTFChars(joldFilePath, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">char</span>* newFilePath = (<span class="hljs-keyword">char</span>*)env-&gt;GetStringUTFChars(jnewFilePath, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">char</span>* patchFilePath = (<span class="hljs-keyword">char</span>*)env-&gt;GetStringUTFChars(jpatchFilePath, <span class="hljs-number">0</span>);

	<span class="hljs-keyword">int</span> argc = <span class="hljs-number">4</span>; 

	<span class="hljs-keyword">char</span>* argv[<span class="hljs-number">4</span>];
	<span class="hljs-comment">// 无效参数 , 可以为任意字符</span>
	argv[<span class="hljs-number">0</span>] = <span class="hljs-string">"bsdiff"</span>;
	<span class="hljs-comment">// 老版APK文件路径</span>
	argv[<span class="hljs-number">1</span>] = oldFilePath;
	<span class="hljs-comment">// 新版APK文件路径</span>
	argv[<span class="hljs-number">2</span>] = newFilePath;
	<span class="hljs-comment">// 生成的差分包文件路径</span>
	argv[<span class="hljs-number">3</span>] = patchFilePath;

	<span class="hljs-comment">// 调用bsdiff</span>
	bsdiff_main(argc, argv);

}
</code></pre><p>一切修改完毕 ， 别忘了在项目属性配置类型，改为生成<code>.dll</code>动态库 。编译生成 ， 这时候会出现很多错误 ， 举几个我遇到的 。</p><p>一 ， 使用了非安全的函数 ， 在文件中声明<code>#define _CRT_SECURE_NO_WARNINGS</code>即可 。</p><p>二 ， 在VS中通不过安全语法检查 ， 在VS中进行如下设置：</p><p><img src="http://upload-images.jianshu.io/upload_images/643851-c140f1c2a9d76859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VS setting"><br>还需要在文件中添加<code>#define _CRT_NONSTDC_NO_DEPRECATE</code>预处理指令。也可以在项目属性中配置：</p><figure><img src="http://upload-images.jianshu.io/upload_images/643851-922fce342dcb2671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VS Config"><figcaption>VS Config</figcaption></figure><p>三 ， 变量未初始化</p><pre class="hljs"><code>	u_char *old = <span class="hljs-literal">nullptr</span>,*_new = <span class="hljs-literal">nullptr</span>;
	<span class="hljs-keyword">off_t</span> oldsize,newsize;
	<span class="hljs-keyword">off_t</span> *I,*V = <span class="hljs-literal">nullptr</span>;
</code></pre><p>可能会是这几个 ， 将其赋值为<code>nullptr</code>就可以了。 如果还有其他错误 ， 可执行分析 ， google ， 也欢迎评论留言 ， 多多交流 。</p><blockquote><p>其三 ， 生成.dll动态库 ， 并使用</p></blockquote><p>将生成的<code>.dll</code>动态库 ， 赋值到服务器项目的目录下 ， 或是Java项目也可以 。</p><p>差分包工具类：</p><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BsdiffUtils</span> </span>{
			
		<span class="hljs-comment">/**
		 * 生成差分包
		 * <span class="hljs-doctag">@param</span> oldFilePath 老版本文件路径
		 * <span class="hljs-doctag">@param</span> newFilePath 新版本文件路径
		 * <span class="hljs-doctag">@param</span> patchFilePath 生成差分包文件路径
		 */</span>
		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">diff</span><span class="hljs-params">(String oldFilePath , String newFilePath , String patchFilePath)</span> </span>;
		
		
		<span class="hljs-keyword">static</span> {
			System.loadLibrary(<span class="hljs-string">"BsdiffJNI"</span>);
		}
}
</code></pre><p>使用差分包工具类：</p><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BsdiffApk</span> </span>{
	
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{
		
		<span class="hljs-comment">/**
		 * 文件差分
		 */</span>
		BsdiffUtils.diff(Constract.OLD_FILE_PATH, Constract.NEW_FILE_PATH, Constract.PATCH_FILE_PATH);
	}
}
</code></pre><p>常量类：</p><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Constract</span> </span>{

	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String OLD_FILE_PATH = <span class="hljs-string">"E:/javaee_workspace/AppUpdateServer/apk/app-old.apk"</span> ;
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NEW_FILE_PATH = <span class="hljs-string">"E:/javaee_workspace/AppUpdateServer/apk/app-new.apk"</span> ;
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PATCH_FILE_PATH = <span class="hljs-string">"E:/javaee_workspace/AppUpdateServer/apk/App_patch.patch"</span> ;
}
</code></pre><p>生成差分包：</p><figure><img src="http://upload-images.jianshu.io/upload_images/643851-aed794d00c605502.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="差分包"><figcaption>差分包</figcaption></figure><h3 id="结语">结语 <a class="markdownIt-Anchor" href="#结语">#</a></h3><p>使用第三方库的时候 ， 自己编写的代码比较少 ， 主要是学会怎样使用第三方的库，以及编译生成动态库的时候 ， 需要查错找错并修改 ， 下篇 ， 我们将实现 ， 在客户端合并差分包 。</p></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../ndk/ndk-2-file-split-join.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../ndk/ndk-4-update-2.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.15</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../c/index.html">C语言基础</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../c/c-1-basic.html">基础语法</a></li><li class="chapter-item"><a href="../c/c-2-pointer.html">指针内存分析</a></li><li class="chapter-item"><a href="../c/c-3-func-2pointer.html">函数与二级指针</a></li><li class="chapter-item"><a href="../c/c-4-func-pointer.html">函数指针</a></li><li class="chapter-item"><a href="../c/c-5-dynamic-m.html">动态内存分配</a></li><li class="chapter-item"><a href="../c/c-6-str-op.html">字符操作</a></li><li class="chapter-item"><a href="../c/c-7-struct-pointer.html">结构体与指针</a></li><li class="chapter-item"><a href="../c/c-8-file-io.html">文件IO</a></li><li class="chapter-item"><a href="../c/c-9-enum.html">联合体与枚举</a></li><li class="chapter-item"><a href="../c/c-10-jni.html">预编译及jni-h分析</a></li></ul><li class="chapter-item"><a href="../cpp/index.html">C++基础</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../cpp/cpp-1-namespace-struct-ref.html">命名空间结构体和引用</a></li><li class="chapter-item"><a href="../cpp/cpp-2-constructor-copy_func.html">构造函数，析构函数，拷贝构造函数</a></li><li class="chapter-item"><a href="../cpp/cpp-3-oop.html">new对象，继承，友元函数，函数的可变参数</a></li><li class="chapter-item"><a href="../cpp/cpp-4-template-exception.html">多态，模板，异常</a></li></ul><li class="chapter-item"><a href="../jni/index.html">Java与C通信的桥梁-JNI</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../jni/jni-1-basic.html">JNI概念及开发流程</a></li><li class="chapter-item"><a href="../jni/jni-2-h-file.html">头文件分析</a></li><li class="chapter-item"><a href="../jni/jni-3-call-java-field-method.html">C语言调用Java字段与方法</a></li><li class="chapter-item"><a href="../jni/jni-4-call-constructor-method.html">C语言调用构造方法</a></li><li class="chapter-item"><a href="../jni/jni-5-ref-handle.html">对象引用的处理</a></li></ul><li class="chapter-item"><a href="../ndk/index.html">Android NDK编写</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../ndk/ndk-1-as-ndk.html">使用Android-Studio编写NDK</a></li><li class="chapter-item"><a href="../ndk/ndk-2-file-split-join.html">文件加密解密与分割合并</a></li><li class="chapter-item chapter-item-current"><a href="../ndk/ndk-3-update-1.html">增量更新之服务器端生成差分包</a></li><li class="chapter-item"><a href="../ndk/ndk-4-update-2.html">增量更新之客户端合并差分包</a></li><li class="chapter-item"><a href="../ndk/ndk-5-conf.html">基于已有项目的NDK环境配置</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"ndk/ndk-3-update-1.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li>\n<ul>\n<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%EF%BC%9F">为什么需要增量更新？</a></li>\n<li><a href="#%E5%A2%9E%E9%87%8F%E5%8E%9F%E7%90%86%EF%BC%88%E5%9B%BE%EF%BC%89">增量原理（图）</a></li>\n<li><a href="#%E7%94%9F%E4%BA%A7%E8%B5%84%E6%BA%90%E5%8F%8A%E5%B7%A5%E5%85%B7">生产资源及工具</a></li>\n<li><a href="#%E7%BC%96%E5%86%99bsdiff-jni">编写bsdiff JNI</a></li>\n<li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>